/*
 * EJS Embedded JavaScript templates
 * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *         http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict"; var fs = require("fs"), path = require("path"), utils = require("./utils"), scopeOptionWarned = !1, _VERSION_STRING = require("../package.json").version, _DEFAULT_OPEN_DELIMITER = "<", _DEFAULT_CLOSE_DELIMITER = ">", _DEFAULT_DELIMITER = "%", _DEFAULT_LOCALS_NAME = "locals", _NAME = "ejs", _REGEX_STRING = "(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)", _OPTS_PASSABLE_WITH_DATA = ["delimiter", "scope", "context", "debug", "compileDebug", "client", "_with", "rmWhitespace", "strict", "filename", "async"], _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat("cache"), _BOM = /^\uFEFF/; function resolvePaths(e, t) { var n; if (t.some(function (t) { return n = exports.resolveInclude(e, t, !0), fs.existsSync(n) })) return n } function getIncludePath(e, t) { var n, r, s = t.views, i = /^[A-Za-z]+:\\|^\//.exec(e); if (i && i.length) e = e.replace(/^\/*/, ""), n = Array.isArray(t.root) ? resolvePaths(e, t.root) : exports.resolveInclude(e, t.root || "/", !0); else if (t.filename && (r = exports.resolveInclude(e, t.filename), fs.existsSync(r) && (n = r)), !n && Array.isArray(s) && (n = resolvePaths(e, s)), !n && "function" != typeof t.includer) throw new Error('Could not find the include file "' + t.escapeFunction(e) + '"'); return n } function handleCache(e, t) { var n, r = e.filename, s = arguments.length > 1; if (e.cache) { if (!r) throw new Error("cache option requires a filename"); if (n = exports.cache.get(r)) return n; s || (t = fileLoader(r).toString().replace(_BOM, "")) } else if (!s) { if (!r) throw new Error("Internal EJS error: no file name or template provided"); t = fileLoader(r).toString().replace(_BOM, "") } return n = exports.compile(t, e), e.cache && exports.cache.set(r, n), n } function tryHandleCache(e, t, n) { var r; if (!n) { if ("function" == typeof exports.promiseImpl) return new exports.promiseImpl(function (n, s) { try { n(r = handleCache(e)(t)) } catch (e) { s(e) } }); throw new Error("Please provide a callback function") } try { r = handleCache(e)(t) } catch (e) { return n(e) } n(null, r) } function fileLoader(e) { return exports.fileLoader(e) } function includeFile(e, t) { var n = utils.shallowCopy({}, t); if (n.filename = getIncludePath(e, n), "function" == typeof t.includer) { var r = t.includer(e, n.filename); if (r && (r.filename && (n.filename = r.filename), r.template)) return handleCache(n, r.template) } return handleCache(n) } function rethrow(e, t, n, r, s) { var i = t.split("\n"), a = Math.max(r - 3, 0), o = Math.min(i.length, r + 3), c = s(n), l = i.slice(a, o).map(function (e, t) { var n = t + a + 1; return (n == r ? " >> " : "    ") + n + "| " + e }).join("\n"); throw e.path = c, e.message = (c || "ejs") + ":" + r + "\n" + l + "\n\n" + e.message, e } function stripSemi(e) { return e.replace(/;(\s*$)/, "$1") } function Template(e, t) { t = t || {}; var n = {}; this.templateText = e, this.mode = null, this.truncate = !1, this.currentLine = 1, this.source = "", n.client = t.client || !1, n.escapeFunction = t.escape || t.escapeFunction || utils.escapeXML, n.compileDebug = !1 !== t.compileDebug, n.debug = !!t.debug, n.filename = t.filename, n.openDelimiter = t.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER, n.closeDelimiter = t.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER, n.delimiter = t.delimiter || exports.delimiter || _DEFAULT_DELIMITER, n.strict = t.strict || !1, n.context = t.context, n.cache = t.cache || !1, n.rmWhitespace = t.rmWhitespace, n.root = t.root, n.includer = t.includer, n.outputFunctionName = t.outputFunctionName, n.localsName = t.localsName || exports.localsName || _DEFAULT_LOCALS_NAME, n.views = t.views, n.async = t.async, n.destructuredLocals = t.destructuredLocals, n.legacyInclude = void 0 === t.legacyInclude || !!t.legacyInclude, n.strict ? n._with = !1 : n._with = void 0 === t._with || t._with, this.opts = n, this.regex = this.createRegex() } exports.cache = utils.cache, exports.fileLoader = fs.readFileSync, exports.localsName = _DEFAULT_LOCALS_NAME, exports.promiseImpl = new Function("return this;")().Promise, exports.resolveInclude = function (e, t, n) { var r = path.dirname, s = path.extname, i = (0, path.resolve)(n ? t : r(t), e); return s(e) || (i += ".ejs"), i }, exports.compile = function (e, t) { return t && t.scope && (scopeOptionWarned || (console.warn("`scope` option is deprecated and will be removed in EJS 3"), scopeOptionWarned = !0), t.context || (t.context = t.scope), delete t.scope), new Template(e, t).compile() }, exports.render = function (e, t, n) { var r = t || {}, s = n || {}; return 2 == arguments.length && utils.shallowCopyFromList(s, r, _OPTS_PASSABLE_WITH_DATA), handleCache(s, e)(r) }, exports.renderFile = function () { var e, t, n = Array.prototype.slice.call(arguments), r = n.shift(), s = { filename: r }; return "function" == typeof arguments[arguments.length - 1] && (e = n.pop()), n.length ? (t = n.shift(), n.length && utils.shallowCopy(s, n.pop()), s.filename = r) : t = {}, tryHandleCache(s, t, e) }, exports.Template = Template, exports.clearCache = function () { exports.cache.reset() }, Template.modes = { EVAL: "eval", ESCAPED: "escaped", RAW: "raw", COMMENT: "comment", LITERAL: "literal" }, Template.prototype = { createRegex: function () { var e = _REGEX_STRING, t = utils.escapeRegExpChars(this.opts.delimiter), n = utils.escapeRegExpChars(this.opts.openDelimiter), r = utils.escapeRegExpChars(this.opts.closeDelimiter); return e = e.replace(/%/g, t).replace(/</g, n).replace(/>/g, r), new RegExp(e) }, compile: function () { var e, t, n, r = this.opts, s = "", i = "", a = r.escapeFunction, o = r.filename ? JSON.stringify(r.filename) : "undefined"; if (!this.source) { if (this.generateSource(), s += '  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n', r.outputFunctionName && (s += "  var " + r.outputFunctionName + " = __append;\n"), r.destructuredLocals && r.destructuredLocals.length) { for (var c = "  var __locals = (" + r.localsName + " || {}),\n", l = 0; l < r.destructuredLocals.length; l++) { var p = r.destructuredLocals[l]; l > 0 && (c += ",\n  "), c += p + " = __locals." + p } s += c + ";\n" } !1 !== r._with && (s += "  with (" + r.localsName + " || {}) {\n", i += "  }\n"), i += "  return __output;\n", this.source = s + this.source + i } e = r.compileDebug ? "var __line = 1\n  , __lines = " + JSON.stringify(this.templateText) + "\n  , __filename = " + o + ";\ntry {\n" + this.source + "} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n" : this.source, r.client && (e = "escapeFn = escapeFn || " + a.toString() + ";\n" + e, r.compileDebug && (e = "rethrow = rethrow || " + rethrow.toString() + ";\n" + e)), r.strict && (e = '"use strict";\n' + e), r.debug && console.log(e), r.compileDebug && r.filename && (e = e + "\n//# sourceURL=" + o + "\n"); try { if (r.async) try { n = new Function("return (async function(){}).constructor;")() } catch (e) { throw e instanceof SyntaxError ? new Error("This environment does not support async/await") : e } else n = Function; t = new n(r.localsName + ", escapeFn, include, rethrow", e) } catch (e) { throw e instanceof SyntaxError && (r.filename && (e.message += " in " + r.filename), e.message += " while compiling ejs\n\n", e.message += "If the above error is not helpful, you may want to try EJS-Lint:\n", e.message += "https://github.com/RyanZim/EJS-Lint", r.async || (e.message += "\n", e.message += "Or, if you meant to create an async function, pass `async: true` as an option.")), e } var u = r.client ? t : function (e) { return t.apply(r.context, [e || {}, a, function (t, n) { var s = utils.shallowCopy({}, e); return n && (s = utils.shallowCopy(s, n)), includeFile(t, r)(s) }, rethrow]) }; if (r.filename && "function" == typeof Object.defineProperty) { var m = r.filename, h = path.basename(m, path.extname(m)); try { Object.defineProperty(u, "name", { value: h, writable: !1, enumerable: !1, configurable: !0 }) } catch (e) { } } return u }, generateSource: function () { this.opts.rmWhitespace && (this.templateText = this.templateText.replace(/[\r\n]+/g, "\n").replace(/^\s+|\s+$/gm, "")), this.templateText = this.templateText.replace(/[ \t]*<%_/gm, "<%_").replace(/_%>[ \t]*/gm, "_%>"); var e = this, t = this.parseTemplateText(), n = this.opts.delimiter, r = this.opts.openDelimiter, s = this.opts.closeDelimiter; t && t.length && t.forEach(function (i, a) { var o; if (0 === i.indexOf(r + n) && 0 !== i.indexOf(r + n + n) && (o = t[a + 2]) != n + s && o != "-" + n + s && o != "_" + n + s) throw new Error('Could not find matching close tag for "' + i + '".'); e.scanLine(i) }) }, parseTemplateText: function () { for (var e, t = this.templateText, n = this.regex, r = n.exec(t), s = []; r;)0 !== (e = r.index) && (s.push(t.substring(0, e)), t = t.slice(e)), s.push(r[0]), t = t.slice(r[0].length), r = n.exec(t); return t && s.push(t), s }, _addOutput: function (e) { if (this.truncate && (e = e.replace(/^(?:\r\n|\r|\n)/, ""), this.truncate = !1), !e) return e; e = (e = (e = (e = e.replace(/\\/g, "\\\\")).replace(/\n/g, "\\n")).replace(/\r/g, "\\r")).replace(/"/g, '\\"'), this.source += '    ; __append("' + e + '")\n' }, scanLine: function (e) { var t, n = this.opts.delimiter, r = this.opts.openDelimiter, s = this.opts.closeDelimiter; switch (t = e.split("\n").length - 1, e) { case r + n: case r + n + "_": this.mode = Template.modes.EVAL; break; case r + n + "=": this.mode = Template.modes.ESCAPED; break; case r + n + "-": this.mode = Template.modes.RAW; break; case r + n + "#": this.mode = Template.modes.COMMENT; break; case r + n + n: this.mode = Template.modes.LITERAL, this.source += '    ; __append("' + e.replace(r + n + n, r + n) + '")\n'; break; case n + n + s: this.mode = Template.modes.LITERAL, this.source += '    ; __append("' + e.replace(n + n + s, n + s) + '")\n'; break; case n + s: case "-" + n + s: case "_" + n + s: this.mode == Template.modes.LITERAL && this._addOutput(e), this.mode = null, this.truncate = 0 === e.indexOf("-") || 0 === e.indexOf("_"); break; default: if (this.mode) { switch (this.mode) { case Template.modes.EVAL: case Template.modes.ESCAPED: case Template.modes.RAW: e.lastIndexOf("//") > e.lastIndexOf("\n") && (e += "\n") }switch (this.mode) { case Template.modes.EVAL: this.source += "    ; " + e + "\n"; break; case Template.modes.ESCAPED: this.source += "    ; __append(escapeFn(" + stripSemi(e) + "))\n"; break; case Template.modes.RAW: this.source += "    ; __append(" + stripSemi(e) + ")\n"; break; case Template.modes.COMMENT: break; case Template.modes.LITERAL: this._addOutput(e) } } else this._addOutput(e) }this.opts.compileDebug && t && (this.currentLine += t, this.source += "    ; __line = " + this.currentLine + "\n") } }, exports.escapeXML = utils.escapeXML, exports.VERSION = _VERSION_STRING, exports.name = _NAME, "undefined" != typeof window && (window.ejs = exports);